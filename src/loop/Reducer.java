package loop;

import loop.ast.*;

import java.util.ArrayList;
import java.util.List;

/**
 * Takes an AST generated by the parser and strips it of unnecessary elements.
 * Also optimizes the AST to be in its most compact form.
 */
public class Reducer {
  private Node ast;

  public Reducer(Node ast) {
    this.ast = ast;
  }

  public Node reduce() {
    // Unwrap top level.
    if (shouldUnwrap(ast)) {
      ast = onlyChildOf(ast);
    }

    return reduce(ast);
  }

  private Node reduce(Node bloated) {
    List<Node> reduced = new ArrayList<Node>();
    for (Node node : bloated.children()) {
      node = reduce(node);

      // Unwrap any redundant wrappers.
      if (shouldUnwrap(node)) {
        reduced.add(onlyChildOf(node));
        continue;
      }

      reduced.add(node);
    }

    // Reduce non-children sub-nodes (many of these in various special cases).
    if (bloated instanceof IndexIntoList) {
      IndexIntoList indexIntoList = (IndexIntoList) bloated;

      // See if the nodes themselves merit reduction.
      if (null != indexIntoList.from()) {
        reduce(indexIntoList.from());
        if (shouldUnwrap(indexIntoList.from())) {
          indexIntoList.from(onlyChildOf(indexIntoList.from()));
        }
      }
      if (null != indexIntoList.to()) {
        reduce(indexIntoList.to());
        if (shouldUnwrap(indexIntoList.to())) {
          indexIntoList.to(onlyChildOf(indexIntoList.to()));
        }
      }
    } else if (bloated instanceof Comprehension) {
      Comprehension comprehension = (Comprehension) bloated;

      reduce(comprehension.inList());
      if (shouldUnwrap(comprehension.inList())) {
        comprehension.inList(onlyChildOf(comprehension.inList()));
      }

      // the filter clause is optional.
      if (null != comprehension.filter()) {
        reduce(comprehension.filter());
        if (shouldUnwrap(comprehension.filter())) {
          comprehension.filter(onlyChildOf(comprehension.filter()));
        }
      }
    } else if (bloated instanceof Call) {
      Call call = (Call) bloated;

      if (call.args() != null) {
        reduce(call.args());
      }
    }

    bloated.children().clear();
    bloated.children().addAll(reduced);

    return bloated;
  }

  private Node onlyChildOf(Node node) {
    return node.children().get(0);
  }

  private boolean shouldUnwrap(Node node) {
    return (node instanceof CallChain
           || node instanceof Computation)
        && node.children().size() == 1;
  }
}
